# NoodleBoss
### Class Design

- **厨师 Chef**

  行为：

  - 制作餐点
  - 查看现有食材及状态
  - 查看订单
  - 补充食材

  属性：

  - 容器及其存储的食材列表
  - 厨具列表

- **食材 Ingredients**

  食材分为面条 (rownoodle)，青菜(pakchoi)，大排 (porkPatty) ，虾仁(shrimp)。

  行为：

  - 可食用状态变化（可食用、腐烂）

  属性：

  - 可食用状态百分比

- **厨具 Cooker**

  厨具分为操作台(CounterTop)，灶台(Hearth)。

- **容器 Container**

  容器分为冰箱(Fridge)，壁橱(Cabinet)，碗(Bowl)。

  行为：

  - 存放食材/面
  - 取出

- **商品 Merch**

  - **单点**

    - **面条 Noodles**

      面条分为：大排面(PorkNoodles)，虾仁面(ShrimpNoodles)，素面(VegetarianNoodles)。

      属性：

      - 所需食材列表
      - 价格

    - **饮品 Beverage**
      饮品分为：可乐(Coke)，橙汁(OrangeJuice)。

  - **套餐 Set**

    属性：

    - 商品列表

* **订单 Order**

### Design Pattern

- **单例模式 Singleton** 

  厨师自身，厨具都是唯一一个

- **抽象工厂模式 AbstractFactory** 

  商品分为单点、套餐两类。创建商品时，通过抽象工厂生成单点（或套餐）的工厂，再通过该工厂生成具体的商品

- **工厂模式 Factory** 

  生成面条、套餐等商品时，根据提供的商品类型生成对象。

- **模版模式 Template**  

  不同厨具的烹饪方法不同

- **观察者模式 Observer** 

  系统时间的改变，会被食材观测到，影响食材的新鲜程度

- **迭代器模式 Iterator** 

  遍历容器中的食材

  遍历订单的商品

- **状态模式 State** 

  食材的状态（生、熟、腐烂）会影响它是否可以被加入菜品

- **命令模式 Command** 

  厨师操控食材、菜品

- **装饰器模式 Decorator** 

  菜品装盘

- **策略模式 Strategy** 

  处理原材料的时候，不同材料设置不同的厨具（Strategy）从而烹饪的方法也不同

- **建造者模式 Builder** 

  创建订单，订单中面条、饮料的选择顺序对订单的最终产出没有影响

- **桥接模式 Bridge** 

  容器在监测原料的可食用状态变化时实际上使用的是原料的内部方法

  订单总价实际上为订单内部所有汉堡的总价

- **外观模式 Facade** 

  厨师对外只暴露处理订单的接口，内部实现处理的逻辑是取食材、加工、整合。。。

- **原型模式 Prototype** 

  厨师可以补充原材料，此处可用现有原材料进行克隆

- **备忘录模式 Memento** 

  食材处理过程可能出现意外，需要备忘录机制来进行处理。食材的状态和新鲜程度保存在备忘录中，处理食材之前可以先保存当前状态。

- **代理模式 Proxy**

  下单时虽然目标是商品本身，但是实际实现是通过订单中添加商品

- **空对象模式 Null Object** 

  在创建订单时，有可能出现指定的商品不存在，直接返回一个空商品（价格为0）

- **组合模式 Composite** 

  订单中既可以包含食品、又可以包含食品组成的套餐

- **访问者模式 Visitor** 

  厨师通过访问者访问冰箱、橱柜里的食材
